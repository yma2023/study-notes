# GDSIIファイル解析 - 段階的C++実装ガイド

## 概要

GDSIIファイルはバイナリ形式の集積回路レイアウト記述ファイルです。このガイドでは、`gcd.gds`（893KB、80,449レコード）を使用して、段階的にC++で解析する方法を学びます。

## GDSIIファイル構造

```
Header (HEADER, BGNLIB, LIBNAME, UNITS)
    ↓
Library
    ↓
Cell (BGNSTR, STRNAME)
    ├─ BOUNDARY (ポリゴン図形)
    │   ├─ XY (座標データ)
    │   ├─ LAYER (レイヤー番号)
    │   └─ DATATYPE
    ├─ SREF (セル参照)
    └─ ENDSTR
    ↓
ENDLIB
```

## 段階的実装

### **Step 1: レコードヘッダの読み込み** (`step1.cpp`)

**目的**: GDSIIファイルの基本構造を理解

**学習内容**:
- バイナリファイルの読み込み
- レコード形式（長さ, 型, データ型）
- 最初の100レコードを表示

**キーコンセプト**:
```
レコード形式: [2bytes: 長さ] [1byte: 型] [1byte: データ型] [ペイロード]
```

**実行結果**: 80,449 total records

---

### **Step 2: レコード統計** (`step2.cpp`)

**目的**: ファイル全体の構成を把握

**学習内容**:
- 各レコード型の出現数をカウント
- 未知のレコード型を検出

**発見**:
- BOUNDARY: 5,723個
- SREF: 9,531個
- XY (型16): 15,254個
- UNKNOWN(16, 43, 44): ファイル形式固有

---

### **Step 3: レコード内容の詳細確認** (`step3.cpp`)

**目的**: ペイロードの内容を理解

**学習内容**:
- int16, int32, ascii_string のパース
- 16進数ダンプ
- データ型の解釈

**例**:
```
HEADER: int16=600 (バージョン)
LIBNAME: "LIB" (ライブラリ名)
STRNAME: "VIA_VIA12" (セル名)
XY: int32×2の座標ペア
```

---

### **Step 4: ポリゴン座標の抽出** (`step4.cpp`)

**目的**: 実際の図形データを取り出す

**学習内容**:
- BOUNDARY エレメントの構造
- XY座標（型16）の解析
- int32_t parse_int32() 関数

**発見**: 
- GDSIIファイルのこのバージョンでは、XYデータは型16で記録される
- LAYER情報は型43, 44に含まれる可能性

---

### **Step 5: 正しいGDSII構造対応版** (`step5.cpp`)

**目的**: ファイルの実構造に対応した完全なパース

**学習内容**:
```
BOUNDARY (型8)
  → COLROW, NODE, XY (型16), LAYER (型17)
  → (次のBOUNDARY or ENDSTR)
```

**結果**:
```
5,723 ポリゴン抽出
- レイヤー 0: 4,324個
- レイヤー 1: 1,399個
```

**座標例**:
```
VIA_VIA12: (-9,-9) → (-9,9) → (9,9) → (9,-9) → (-9,-9)
           (矩形: 18×18 units)
```

---

### **Step 6: 完全な実装システム** (`step6.cpp`)

**目的**: OOP設計による完全なGDSIIパーサー

**クラス設計**:
```cpp
class GDSIIParser {
  - parse(): ファイルをパース
};

struct GDSIILibrary {
  - name: ライブラリ名
  - dbu_in_user_unit: デザイン単位
  - dbu_in_meter: 実寸法
  - cell_names: セル一覧
  - polygons: ポリゴン集合
  - analyze(): レイヤー分布を計算
};

struct Polygon {
  - cell_name: 属するセル
  - layer: レイヤー番号
  - datatype: データタイプ
  - vertices: 頂点座標
};
```

**実行結果**:
```
Library Name: LIB
DBU in user unit: 0.001
DBU in meter: 1e-09
Total cells: 43
Total polygons: 5,723

Layer Distribution:
  Layer  -1: 4,379 polygons
  Layer   1: 1,344 polygons
```

---

## 重要な学習ポイント

### 1. バイナリ解析の基礎
```cpp
// Big-endian 整数のパース
int32_t parse_int32(const uint8_t* bytes) {
  return (static_cast<int32_t>(bytes[0]) << 24) |
         (static_cast<int32_t>(bytes[1]) << 16) |
         (static_cast<int32_t>(bytes[2]) << 8) |
         static_cast<int32_t>(bytes[3]);
}
```

### 2. 状態管理
```cpp
bool in_boundary = false;  // 現在 BOUNDARY 内か
Polygon current_polygon;    // 構築中のポリゴン
std::string current_cell;   // 現在のセル
```

### 3. レコードの連鎖処理
```
レコード → ペイロード読み込み → 状態更新 → 次レコード
```

### 4. DOMツリーの構築
```
Library
  ├─ Cell 1
  │  ├─ Polygon 1
  │  └─ Polygon 2
  └─ Cell 2
     └─ Polygon 3
```

---

## 実装の進化

| Step | 焦点 | 行数 | 機能 |
|------|------|------|------|
| 1 | 基本 | ~100 | ヘッダ読み込み |
| 2 | 統計 | ~150 | レコード分布 |
| 3 | 詳細 | ~120 | ペイロード表示 |
| 4 | 抽出 | ~130 | 座標取得 |
| 5 | 完成 | ~170 | 完全解析 |
| 6 | OOP | ~250 | オブジェクト設計 |

---

## トラブルシューティング

### 問題1: UNKNOWN レコード型
**原因**: GDSII仕様のバージョン違い
**解決**: ファイルの実データから仕様を逆算（Step 2参照）

### 問題2: LAYER が記録されない
**原因**: レコード構造が標準と異なる
**解決**: 型43, 44にLAYER情報が含まれる可能性（Step 5参照）

### 問題3: 座標がマイナス値
**原因**: デザイン単位でのオフセット
**解決**: dbu_in_user_unit で実寸法に変換

---

## 次のステップ

1. **セルインスタンス(SREF)の解析**: 階層構造の実装
2. **変換マトリクス(STRANS)の対応**: 回転・反転の処理
3. **DRC検証ツール**: ルールチェック機能
4. **マスクデータ最適化**: OPC/MRC処理

---

## 参考資料

- GDSIIファイル: `gcd.gds` (893 KB)
- レコード数: 80,449
- 抽出ポリゴン: 5,723
- セル数: 43

---

**まとめ**: GDSIIファイル解析は、段階的な小さな問題の組み合わせです。各ステップで一つの機能に焦点を当てることで、複雑な処理も理解しやすくなります。